* 나중에 주석 내용 해당 파일로 이동

[의존 관계 주입 방법]
 의존관계 주입은 내부적으로 모든 빈을 등록한 후에 이루어진다(생성자 주입은 예외)
 1. 생성자 주입
  - 개념 : @Autowired를 이용하여, 생성자의 인자를 통한 의존성 주입
  - 특징 : 생성자 호출 시점에 실행이 되어 주입되므로, 1번만 실행되며, 이후에는 실행할 수 없으므로 추가로 객체를 만드는 것을 막을 수 있다.
           불변, 필수 의존 관계에 이용

 2. 수정자 주입(Setter 주입)
  - 개념 : 수정자(Setter)에 @Autowired를 붙여서, 의존성(동작시 필요한 객체 등)을 주입
  - 특징 : 어노테이션이 붙은 세터에 필요한 인자가 없더라도 작성하여 컴파일이 가능하며, 인자가 없어도 오류가 나지않기에 선택적으로 의존관계를 주입할 수 있다. 단, 선택적으로 이용하기 위해서는 @Autowired(required = false)로 값을 지정해 줘야함
           선택,변경 의존 관계에 이용

 3. 필드 주입
   - 개념 : 변수에 직접적으로(필드에서 발생) 어노테이션을 사용하여 주입 / private로 객체형 변수를 가지고 있을 때 사용할 수 있다
   - 특징 : 간결하지만 인텔리제이에서는 사용시 경고문구가 뜬다
            수정자 및 생성자를 통한 주입은 테스트할 때(스프링사용 없이 순수 자바 이용시) 직접 객체를 넣어서 테스트 할 수 있지만, 필드주입은 직접넣을 방법이 없으므로, 값 확인과 테스트가 번거로워지며, 결국 세터를 필요로 하게된다
            스프링을 이용하는 테스트 코드는 상관없음.(테스트 코드이므로 누가 쓰지 않으니까) / AppConfig 같은 스프링 설정파일(초반에만 설정을 위해 실행됨)에서는 사용되는 경우가 있다

 4. 일반 메서드 주입
   - 개념 : 일반메서드에 @Autowired를 통한 의존 주입
   - 특징 : 일반적으로 잘 사용하지 않는다 / 아무 메서드에서나 사용하는 것이 아닌, Bean으로 등록된, Bean객체 안에서만 사용가능하다


[롬복]
 1. 설정 : (초기 설치가 아닌 추가 설치일 경우)그레이들빌드 파일에 적용 코드를 작성하고 리로드실시 + 설정->Compile->Annotation Processor->Enable설정

 2. 기능
    - @Getter / @Setter : 클래스에 게터 세터어노테이션을 작성하여, 외부에서 해당 클래스 타입의 객체를 생성시, 자동으로 개터,세터를 지원하게한다 -> HelloLombok파일 참고
    - @RequiredArgConstructor : final이 붙은 필수 변수가 있으면, 해당 변수를 받아오는 생성자를 자동으로 생성한다
    - @ToString : ToString 메서드 지원


[@Autowired]
 1. 특징
   - 생성자가 한개만 있을경우 생략해도 된다.
   - Autowired 는 주입을 명시하는 코드(세터, 생성자)에 사용하는 것이 좋다. -> 추후 테스트 및 관리를 위해서
   - 타입으로 빈을 받을 때, 타입 중복시 이름의 매칭율을 보고 정한다

 2. 주입 값이 없을 때 3가지 방법(선택적으로 Autowired를 사용할 때)
   - required 옵션의 기본값이 True 로 되어있어서, 주입 대상이 없으면, 오류발생 -> False 로 설정하면, 있으면 실행하고, 없으면 실행하지 않으므로, 선택적 실행이 가능하다.
   - @nullable을 이용하면, 주입 대상이 없을 시, Null값을 입력한다.
   - Optional을 이용하면, 주입대상이 없을 때, Null값이 아닌 Optional.empty가 입력된다.


[@Qualifier]
 1. 특징
   - 등록하는 Bean의 이름을 지정할 수있다.
   - 생성자의 인자 옆에 태그를 사용하면, 퀄리파이어에 명시한 이름을 가진 빈과 매칭시켜준다.
   - 퀄리파이어는 빈을 매칭시킬때만 쓰는것이 좋다고함. -> 특정 빈이 특정 인자로 들어갈때, 퀄리파이어를 이용해서 연결

 2. 팁 : 이름에 오타가 생겨도 컴파일러는 잡을 수 없기에, 전용 어노테이션을 만들어서 해당 어노테이션이 지정하이름을 쿼리파이어하게 한다. 오타 발생시 IDE가 잡아준다. -> ratediscountpolicy / maindiscounntpolicy 두 파일 참고


[@Primary]
 1. 특징
   - 빈 매칭시 중복된 매칭이 있으면, 해당 태그가 붙은 빈을 매칭해준다


[빈 생명주기 콜백]
 빈의 초기화 및 안전한 종료를 위한 종료작업을 하는 메서드로, 총 3가지 종류가 있다 : lifeCycle 테스트 패키지 참고
 close메서드는 컨테이너 객체에 사용하며, 사용시 모든 객체의 종료 메서드가 실행됨
 초기화 메서드 : 의존관계 주입 후(생성 후) 실행 -> !빈의 호출이 아닌, 스프링 컨테이너가 생성되는 단계에서 실행됨!
 종료 메서드 : 종료시 실행

 1. 인터페이스(InitializingBean, DisposableBean) : *비권고*
    - 2003년, 스프링 초창기때 나온 방법으로, 유연하지 못하고 확장성이 없어서 현재는 잘 사용하지 않는다.
    - 빈 안에 직접 인터페이스를 상속하고 메서드를 작성해야하지만, 코드를 바꿀 수 없는 외부 라이브러리에는 적용이 불가능하다
    - 해당 인터페이스가 가진 초기화, 소멸 메서드의 이름이 고정이다.

 2. 설정 정보에 초기화 메서드, 종료 메서드 지정 : *외부라이브러리 사용시 권고*
    - 초기화 메서드 및 종료메서드로 지정할 메서드위를 @Bean 어노테이션의 옵션으로 작성한다 : @Bean(initMethod="init", destroyMethod="close")
    - 메서드의 이름을 자유롭게 정할 수 있다. (빈으로 등록되는 쪽에서 이름을 지정하므로)
    - 코드를 수정할 수 없는 외부라이브러리에도 사용이 가능하다(필요 메서드만 빈에서 지정함)
    - @Bean의 destroyMethod는 기본값이 'inffered(추론)'이기에 'close','shutdown' 이라는 이름의 메서드가 있으면 알아서 종료 메서드로 잡아준다. 만약 자동으로 종료메서드를 잡기싫으면 destroyMethod=""옵션을 이용한다

 3. @PostConstruct, @PreDestroy 어노테이션 지원 : *권고*
    - 빈으로 등록될 파일에서 초기화 메서드에 @PostConstruct, 종료 메서드에 @PreDestroy를 붙인다
    - javax패키지에 있는 자바 표준 기능으로, 스프링이 아닌 곳에서도 사용이 가능하다
    - 컴포넌트 스캔과 잘 어울린다
    - 코드 수정이 불가능한 외부라이브러이에 적용이 불가능하다


[빈 스코프]
 빈이 동작하는 범위
 @Bean, @Component 위에 @Scope 어노테이션을 이용하여 설정한다

 1. 스코프의 종류
    - 싱글톤 : 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프 / 기본값
    - 프로토타입 : 빈의 생성과 DI까지만 관여하는 짧은 스코프
    - Request : 웹 요청이 들어오고 나갈때까지 유지
    - Session : 웹 세션이 생성되고 종료될때까지 유지
    - Application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프

 2-1. 프로토타입
    - 싱글톤과 반대로, 매번 새로운 객체를 생성한다.
    - 싱글톤은 스프링 컨테이너 생성시시 바로 초기화 메서드가 실행되지만, 프로토타입은 매번 새로 만들기 때문에 실질적인 사용이 있을때만(조회가 있을때만) 직전에 생성된다.
    - 컨테이너를 close 하더라도 프로토타입 객체는 종료메서드가 실행되지않는다. -> 컨테이너가 만들고 객체를 넘겼기 때문에 생성 직후에는 관리를 하지 않는다
    - 종료시 직접 종료 메서드를 호출해야한다.

 2-2. 싱글톤과 프로토타입 혼용의 문제점
    - 전제 : 싱글톤 빈이 초기화 시점에서 변수로써 프로토타입 빈을 주입받음
    - 상황 : A가 싱글톤 빈에 있는 프로토타입 빈의 메서드를 이용하여, 프로토타입의 카운터 변수를 증가시킴 -> A가 싱글톤 반환 후 B가 같은 행동을 함
    - 결과 : 싱글톤의 프로토타입 빈이 가진 카운터는 중복으로 증가되었음
    - 원인 : 싱글톤 빈의 생성시 프로토타입 빈이 이미 주입된 상태에서, 요청 클라이언트가 다르더라도 이미 주입된 프로토타입은 재생성되지않고 공유되지 때문
    - 해결방안-1 : 생성 시점에 프로토타입 빈을 주입받는 것이 아닌, 필요 메서드에 프로토타입 빈 생성 코드를 작성하여, 매 호출마다 새로 생성한다
    - 해결방안-2 : 외부에서 의존관계를 주입받는 것이 아닌 필요한 의존관계를 직접 찾는 DL을 이용한다 -> ObjectProvider<Type>를 이용하여 원하는 빈을 지정하고, 이후 getObject를 통해서 매번 생성하여 주입한다
    - 해결방안-3 : 자바표준 Provider를 이용한다. get메서드를 통해서 생성가능 / implementation 'javax.inject:javax.inject:1' 해당 코드를 그레이들 빌드에 추가해야한다 -> 프로바이더를 사용하면 매 생성마다 프로토타입으로 객체에 넣어준다

 3. 웹 스코프
    - HTTP Request가 들어오고 나갈때까지 유지되며, 클라이언트마다 각기 다른 객체가 생성된다
    - 웹 환경을 위한 그레이들 빌드 추가 -> implementation 'org.springframework.boot:spring-boot-starter-web'
    - UUID를 통해서 클라이언트를 구분한다
    - 문제 : 일반적인 방법으로 웹스코프 객체를 생성시, 오류가 발생한다 -> 요청이 있을시에만 생성되므로
    - 해결방안-1 : ObjectProvider를 이용하여, lookup변수를 만든 후, 요청발생 후 처리할 메서드에서 필요한 부분에 주입해준다
    - 해결방안-2 : 스코프 어노테이션의 옵션을 추가한다 : ,proxyMode = ScopedProxyMode.TARGET_CLASS -> 1의 방법또한 좋지만, 기존 코드를 유지하며 어노테이션만을 사용하여 문제를 해결할 수 있다.
                  가짜 프록시 클래스를 만들어서 미리 빈을 주입한다. 즉 지연처리한다

[Tip]
 - 수동빈은 업무로직빈에 사용하는 것보다, 내부동작(기술지원빈)에 사용하는 것이 좋다. -> 수동 conf파일을 작성하면, 수동 등록의 특성상 모든 빈을 작성해야하므로, 현재 등록되어있는 내부동작을 한눈에 볼 수 있다
 - 내부 객체 변수는 final을 써주는 것이 좋다 : 값의 선언이 없으면, 오류로 잡히므로, 생성자에서 인자를 변수로 넣는 과정을 생략해서 오류 발생시 찾는 시간을 줄일 수 있다. -> 해당 객체 변수의 오류를 어느정도 컨트롤 할 수 있음 * 단, 생성자 주입방식만 사용가능
 - 구현빈끼리 패키지에 모으면 관리가 편해짐
 - 계층 : ApplicationContext > ConfigurableApplicationContext > AnnotationConfigApplicationContext
 - AnnotationConfigApplicationContext의 인자로 꼭 @Component가 붙어있지 않아도 된다. 인자로 넘긴 순간 컴포넌트로 취급하고 읽기 시작한다
 - Ctrl + Alt + N : 코드 단축 -> a = 1; return a; 라는 코드에서 불필요한 a를 제외하고, return 1; 줄여준다
 - 스프링 웹 접속 포트 변경방법 main/resources/application.properties 파일에 server.port=원하는 포트번호 를 추가해준다.

